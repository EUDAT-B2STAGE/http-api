5420406629dbcf1a713d33732d91b4802273bb6f diff --git a/commons/databases/__init__.py b/commons/databases/__init__.py index 6f5db83..c0eea9c 100644 --- a/commons/databases/__init__.py +++ b/commons/databases/__init__.py @@ -49,3 +49,7 @@ class DBinstance(metaclass=abc.ABCMeta): @abc.abstractmethod def init_connection(self): return + + @abc.abstractmethod + def get_instance(self, *args): + return diff --git a/restapi/resources/services/authentication/graphdb.py b/restapi/resources/services/authentication/graphdb.py index 6ca02fa..f4e2d8a 100644 --- a/restapi/resources/services/authentication/graphdb.py +++ b/restapi/resources/services/authentication/graphdb.py @@ -26,12 +26,11 @@ if not GRAPHDB_AVAILABLE: class Authentication(BaseAuthentication): def __init__(self): - self._graph = GraphFarm().get_graph_instance() + self._graph = GraphFarm().get_instance() def get_user_object(self, username=None, payload=None): user = None - self._graph = GraphFarm().get_graph_instance() try: if username is not None: user = self._graph.User.nodes.get(email=username) diff --git a/restapi/resources/services/detect.py b/restapi/resources/services/detect.py index 14e08e2..317e356 100644 --- a/restapi/resources/services/detect.py +++ b/restapi/resources/services/detect.py @@ -30,9 +30,18 @@ GRAPHDB_AVAILABLE = 'GDB_NAME' in os.environ if GRAPHDB_AVAILABLE: # DO something and inject into 'services' - from .neo4j import graph - logger.info("Graphdb checked %s" % graph) - services['neo4j'] = graph + from .neo4j.graph import GraphFarm as service + services['neo4j'] = service + +####################################################### +# IRODS + +#?? + +####################################################### +# ELASTICSEARCH + +#?? # ####################################################### # # RETHINKDB diff --git a/restapi/resources/services/neo4j/graph.py b/restapi/resources/services/neo4j/graph.py index 730f449..c6d7efb 100644 --- a/restapi/resources/services/neo4j/graph.py +++ b/restapi/resources/services/neo4j/graph.py @@ -6,6 +6,7 @@ import os import time from ....meta import Meta from .... import get_logger +from commons.databases import DBinstance logger = get_logger(__name__) @@ -31,10 +32,10 @@ except Exception as e: # raise e exit(1) -############################################################################## -# GRAPHDB -############################################################################## +####################### +# GRAPHDB main object +######################## class MyGraph(object): """" A graph db neo4j instance """ @@ -79,50 +80,34 @@ class MyGraph(object): def other(self): return self -######################################## -""" -Wait for neo4j connection at startup -""" +####################### +# Farm to get Graph instances +######################## -counter = 0 -sleep_time = 1 -testdb = True -while testdb: - try: - # CREATE INSTANCE - graph = MyGraph() - logger.info("Neo4j seems available") +class GraphFarm(DBinstance): - # Add one model - from neomodel import StructuredNode, StringProperty - - class TestConnection(StructuredNode): - name = StringProperty(unique_index=True) - logger.info("neomodel: checked labeling on active connection") - - testdb = False - except BaseException: - logger.warning("Neo4j: Not reachable yet") + """ Making some Graphs """ - counter += 1 - if counter % 5 == 0: - sleep_time += sleep_time CHANGELOG.md LICENSE README.md __pycache__ boot commons confs docker-compose.yml docs htmlcov instance mkdocs.yml operations operations.py restapi run.py tasks test tests.sh 2 - logger.debug("Awaiting Neo4j: sleep %s" % sleep_time) - time.sleep(sleep_time) + def init_connection(self): -del graph + # CHECK 1: test the environment + self._graph = MyGraph() + logger.info("Neo4j service seems plugged") + # CHECK 2: test the models + # Do not import neomodel before + # because it will force the system to check for the connection + from neomodel import StructuredNode, StringProperty -######################################## -class GraphFarm(object): + class TestConnection(StructuredNode): + name = StringProperty(unique_index=True) - """ Making some Graphs """ + logger.info("neomodel: checked labeling on active connection") - def get_graph_instance( - self, models2skip=[], - pymodule_with_models='.resources.services.neo4j.models'): + def get_instance(self, models2skip=[], + pymodule_with_models='.resources.services.neo4j.models'): # Relative import: Add the name of the package as prefix module = __package__.split('.')[0] + pymodule_with_models diff --git a/restapi/server.py b/restapi/server.py index d88ffe6..a3ec871 100644 --- a/restapi/server.py +++ b/restapi/server.py @@ -129,10 +129,11 @@ def create_app(name=__name__, enable_security=True, ############################## # DATABASE/SERVICEs CHECKS # // TO FIX: -# This could be done with a list of services -# It should be cleared compiled in a docker way +# This list of services should or could be compiled in a docker way from .resources.services.detect import services - logger.info("Available services %s" % services) + for service, myclass in services.items(): + logger.info("Available service %s" % service) + myclass(check_connection=True) ############################## # Flask security diff --git a/run.py b/run.py index 3f255fc..cfefc9f 100755 --- a/run.py +++ b/run.py @@ -41,5 +41,5 @@ if __name__ == "__main__": # Note: 'threaded' option avoid to see # angular request on this server dropping # and becoming slow if not totally frozen - app.run(host=SERVER_HOSTS, port=SERVER_PORT, threaded=True) app.logger.info("*** Running Flask!") + app.run(host=SERVER_HOSTS, port=SERVER_PORT, threaded=True)
! [graph_based_auth] Understaing Restful plugin position into create app. CHANGELOG.md LICENSE README.md __pycache__ boot commons confs docker-compose.yml docs htmlcov instance mkdocs.yml operations operations.py restapi run.py tasks test tests.sh [master] Making the graph one of services to use at startup ! [oauthtest] A working example of b2access authorization. Adding certificates on the http-api repo to make it work. --- CHANGELOG.md LICENSE README.md __pycache__ boot commons confs docker-compose.yml docs htmlcov instance mkdocs.yml operations operations.py restapi run.py tasks test tests.sh [master] Making the graph one of services to use at startup CHANGELOG.md LICENSE README.md __pycache__ boot commons confs docker-compose.yml docs htmlcov instance mkdocs.yml operations operations.py restapi run.py tasks test tests.sh [master^] Starting the `commons` package. CHANGELOG.md LICENSE README.md __pycache__ boot commons confs docker-compose.yml docs htmlcov instance mkdocs.yml operations operations.py restapi run.py tasks test tests.sh [master~2] Loading services at startup using the detect file. CHANGELOG.md LICENSE README.md __pycache__ boot commons confs docker-compose.yml docs htmlcov instance mkdocs.yml operations operations.py restapi run.py tasks test tests.sh [master~3] Updating project readme CHANGELOG.md LICENSE README.md __pycache__ boot commons confs docker-compose.yml docs htmlcov instance mkdocs.yml operations operations.py restapi run.py tasks test tests.sh [master~4] Enabling oauth lib. CHANGELOG.md LICENSE README.md __pycache__ boot commons confs docker-compose.yml docs htmlcov instance mkdocs.yml operations operations.py restapi run.py tasks test tests.sh [master~5] Forwarding errors when testing CHANGELOG.md LICENSE README.md __pycache__ boot commons confs docker-compose.yml docs htmlcov instance mkdocs.yml operations operations.py restapi run.py tasks test tests.sh [master~6] Keeping track of where to continue CHANGELOG.md LICENSE README.md __pycache__ boot commons confs docker-compose.yml docs htmlcov instance mkdocs.yml operations operations.py restapi run.py tasks test tests.sh [master~7] Debugging logout, which has to be completed CHANGELOG.md LICENSE README.md __pycache__ boot commons confs docker-compose.yml docs htmlcov instance mkdocs.yml operations operations.py restapi run.py tasks test tests.sh [master~8] Adding an automatic build for readthedocs CHANGELOG.md LICENSE README.md __pycache__ boot commons confs docker-compose.yml docs htmlcov instance mkdocs.yml operations operations.py restapi run.py tasks test tests.sh [master~9] Allowing the frontend side to decrypt the JWT. CHANGELOG.md LICENSE README.md __pycache__ boot commons confs docker-compose.yml docs htmlcov instance mkdocs.yml operations operations.py restapi run.py tasks test tests.sh [master~10] Bug fix +* [graph_based_auth] Understaing Restful plugin position into create app. +* [graph_based_auth^] Understanding tests and verify where it works +* [graph_based_auth~2] Working some tests +* [graph_based_auth~3] Bug fixing +* [graph_based_auth~4] Making better urls for basic endpoints +* [graph_based_auth~5] Still cleaning old and unused stuff for profiles, endpoints and db +* [graph_based_auth~6] Purging more security/admin old (bad) stuff +* [graph_based_auth~7] Implemented our Authorization class based on Miguel's one. +* [graph_based_auth~8] Making our response more Flask compliant. +* [graph_based_auth~9] Adding the new section of the documentation +* [graph_based_auth~10] Bug fixing for relationaldb +* [graph_based_auth~11] Some bug fixes +* [graph_based_auth~12] Adding a docker environment variable to select auth service +* [graph_based_auth~13] Brainstorming +* [graph_based_auth~14] A working example of custom auth. +* [graph_based_auth~15] A working check of username and password stored inside graph db. +* [graph_based_auth~16] There must be an auth init inside the backend server. +* [graph_based_auth~17] Fixing the login endpoint first draft. +* [graph_based_auth~18] Moving the flask_httpauth lib instance into a file that can be loaded from anywhere +* [graph_based_auth~19] Using decorators for some auth global magic +* [graph_based_auth~20] Another big step towards custom authentication. +* [graph_based_auth~21] Starting some implementation on an abstract base +* [graph_based_auth~22] Saving resources +* [graph_based_auth~23] Some brainstorming +* [graph_based_auth~24] More auth cleaning. Moving modules to be dinamically loaded +* [graph_based_auth~25] Rethinking authentication side. +* [graph_based_auth~26] Making some tests for login endpoint +* [graph_based_auth~27] Move some other logic from vanilla inside the backend +* [graph_based_auth~28] A note on jwt to fix +* [graph_based_auth~29] A working example of coding/decoding a JWT token. +* [graph_based_auth~30] Adding a JWT token creation. +* [graph_based_auth~31] Defining basic user/roles and connect them if none available +* [graph_based_auth~32] removing custom from the base +* [graph_based_auth~33] Changing names +* [graph_based_auth~34] Fixing tests +* [graph_based_auth~35] Moving tests into two separated dirs. -- [graph_based_auth~36] Merge branch 'master' of github.com:EUDAT-B2STAGE/http-api-base into graph_based_auth +* [master~13] Added reference to test doc page +* [master~14] First draft of test documentation +* [master~15] fixed test test_03_post_dataobjects_in_specific_collection +* [master~16] added test with POST in a specific collection (fails with error: The requested collection does not exist) +* [graph_based_auth~37] Using flask login/security methods +* [graph_based_auth~38] Fixing graph functions to make login work +* [graph_based_auth~39] Towards graphdb centric flask +* [graph_based_auth~40] Cleaning up the task list +* [graph_based_auth~41] A stub to override FlaskLogin/Security authentication methods [WARNING: Code is incomplete and still not working] +* [graph_based_auth~42] A note about an Irods error to be parsed -- [graph_based_auth~43] Merge branch 'master' of https://github.com/EUDAT-B2STAGE/http-api-base into irods_commands +* [master~17] Loading dinamically models for the graph -- [graph_based_auth~44] Merge branch 'master' of https://github.com/EUDAT-B2STAGE/http-api-base into irods_commands +* [master~18] Init of the graph at flask server startup. Import from your code the GraphFarmer class and extend it. -- [graph_based_auth~45] Merge branch 'master' of https://github.com/EUDAT-B2STAGE/http-api-base into irods_commands +* [master~19] Fixed tests with new error messaegs -- [graph_based_auth~46] Merge branch 'master' of https://github.com/EUDAT-B2STAGE/http-api-base into irods_commands -- [graph_based_auth~47] Merge branch 'master' of https://github.com/EUDAT-B2STAGE/http-api-base into irods_commands +* [graph_based_auth~48] Fix conflicts between enumerate and list.pop +* [graph_based_auth~49] Implemented a list_as_json function to parse the irods ils. The function is intended to be a stub of irods output parser, it will change with next commits. see #9 +* [graph_based_auth~50] Implemented a get_permissions function to retrieve ACL set on a collection/dataobject, see #3 Output example: { 'path': '/your_zone/your_path/', 'ACL': [ ['your_user', 'your_zone', 'own'], ['other_user', 'your_zone', 'read'] ], 'inheritance': 'Disabled' } +* [graph_based_auth~51] Added a function to verify the existence of an irods user and optionally to verify the membership to an irods group, see #3 + [oauthtest] A working example of b2access authorization. Adding certificates on the http-api repo to make it work. + [oauthtest^] Bug fix for base encoding in python3. + [oauthtest~2] Going forward the b2access protocol + [oauthtest~3] A working example of accessing a token with github api +*+ [master~20] Fixing the regexp for irods errors. Adding some other code parsing.
