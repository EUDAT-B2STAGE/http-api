0bc0b78754861f6528affb2de94fe13a0947a92d diff --git a/restapi/resources/decorators.py b/restapi/resources/decorators.py index ff1a1c2..880d6bd 100644 --- a/restapi/resources/decorators.py +++ b/restapi/resources/decorators.py @@ -198,22 +198,31 @@ def exceptionError(self, label, e): return self.response(errors={label: error}) -def error_handler(func, self, exception, label, args, kwargs): +def error_handler(func, self, exception, label, catch_generic, args, kwargs): out = None - print(func, self, exception, label, args, kwargs) - + # print(func, self, exception, label, args, kwargs) + default_label = 'Server error' + if label is None: + label = default_label try: out = func(self, *args, **kwargs) except exception as e: return exceptionError(self, label, e) except Exception as e: - print("Obtained another exception", e) + logger.warning( + "Unexpected exception inside error handler:
%s" % str(e)) + if not catch_generic: + raise e + else: + return exceptionError( + self, default_label, 'Please contact webadministrators') return out -def catch_error(exception=None, exception_label='Unknown error'): +def catch_error( + exception=None, exception_label=None, catch_generic=True): """ A decorator to preprocess an API class method, and catch a specific error. @@ -221,6 +230,7 @@ def catch_error(exception=None, exception_label='Unknown error'): def decorator(func): def wrapper(self, *args, **kwargs): return error_handler( - func, self, exception, exception_label, args, kwargs) + func, self, + exception, exception_label, catch_generic, args, kwargs) return wrapper return decorator diff --git a/restapi/resources/services/irodsclient.py b/restapi/resources/services/irodsclient.py index 6f874d8..0bdfc7f 100644 --- a/restapi/resources/services/irodsclient.py +++ b/restapi/resources/services/irodsclient.py @@ -46,28 +46,33 @@ class IrodsException(RestApiException): return "Permission denied" def parse_OVERWRITE_WITHOUT_FORCE_FLAG(self, utility, error_string, error_code, error_label, role='user'): - print(error_string, error_code, utility) return "Trying to overwrite the object. Please add the force option" + def parse_USER_INPUT_PATH_ERR(self, utility, error_string, error_code, error_label, role='user'): + return "The requested object does not exist on the specified path" + + def parse_CAT_UNKNOWN_COLLECTION(self, utility, error_string, error_code, error_label, role='user'): + return "The requested collection does not exist" + def parseIrodsError(self, error): error = str(error) - logger.debug(error) + logger.debug("*%s*" % error) - #Error example: - #ERROR: mkdirUtil: mkColl of /abs/path/to/resource error. status = -809000 CATALOG_ALREADY_HAS_ITEM_BY_THAT_NAME - regExpr = "^ERROR: (.*): (.*) status = (-[0-9]+) (.*)$" + # Error example: + # ERROR: mkdirUtil: mkColl of /abs/path/to/resource error. + # status = -809000 CATALOG_ALREADY_HAS_ITEM_BY_THAT_NAME + regExpr = "ERROR: (.+): (.+) status = (-[0-9]+) ([A-Z0-9_]+)" m = re.search(regExpr, error) if m: - utility = m.group(1) #es: mkdirUtil - error_string = m.group(2) #es: mkColl of /abs/path/to/resource error - error_code = int(m.group(3)) #es: -809000 - error_label = m.group(4) #es: CATALOG_ALREADY_HAS_ITEM_BY_THAT_NAME + utility = m.group(1) # es: mkdirUtil + error_string = m.group(2) # es: mkColl of /abs/path/to/resource error + error_code = int(m.group(3)) # es: -809000 + error_label = m.group(4) # es: CATALOG_ALREADY_HAS_ITEM_BY_THAT_NAME method_name = 'parse_%s' % error_label method = getattr(self, method_name, None) if method is not None: - print("TEST") return method(utility, error_string, error_code, error_label) return error_label
[master] Fixing the regexp for irods errors. Adding some other code parsing.
